# Golang 深入理解 GPM 模型

[TOC]

## 目标

![intention](img/intention.png)

## 一、调度器的由来和分析

### 1、单进程时代的两个问题

1. 单一执行流程、计算机只能一个任务一个任务处理
2. 进程阻塞所带来的的 CPU 浪费时间

   ![one](img/one.png)

### 2、多进程、多线程的问题

#### 2.1、设计变得复杂(c++、java)

1. 进程/线程的数量越多，切换成本就越大，也就越浪费
2. 多线程随着同步竞争（如锁、竟争资源冲突等）

#### 2.2、多进程、多线程的壁垒

1. 高内存占用

   > 进程占用内存 -> 虚拟内存 4GB(32bit OS)
   >
   > 线程占用内存 -> 约 4MB

   ![two](img/two.png)

2. 高 CPU 调度消耗

   ![three](img/three.png)

### 3、协程(co-routine),引发的问题

#### 3.1、N:1

1. 无法利用多个 CPU
2. 出现阻塞的瓶颈

#### 3.2、1:1

1. 跟多线程/多进程模型无异
2. 切换协程成本代价昂责

#### 3.3、M:N

1. 能够利用多核
2. 过于依赖协程调度器的优化和算法

### 4、调度器的优化

#### 4.1、Goroutine 的优化

1. 内存占用
   > 几KB，可以大量开辟
2. 灵活调度
   > 切换成本低

#### 4.2、早期 Go 的调度器

基本的全局Go队列和比较传统的轮询利用多个thread去调度

![four](img/four.png)

##### 4.2.1、弊端
![five](img/five.png)


## 二、Gotoutine调度器的GMP模型的设计思想

### 1、GMP模型的简介
### 2、调度器的设计策略
### 3、"go func()"经历了什么过程
### 4、调度器的生命周期
### 5、可视化GMP编程
